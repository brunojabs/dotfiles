syntax enable
set nocompatible              " be iMproved, required
filetype off                  " required
   let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
   let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
 set t_Co=256
" set the runtime path to include Vundle and initialize
call plug#begin('~/.vim/plugged')
Plug 'scrooloose/nerdtree'
Plug 'tpope/vim-rails'
Plug 'airblade/vim-gitgutter'
Plug 'kien/ctrlp.vim'
" Plug 'ervandew/supertab'
Plug 'tpope/vim-endwise'
Plug 'phaazon/hop.nvim'
"Plug 'vim-airline/vim-airline'
"Plug 'vim-airline/vim-airline-themes'
 Plug 'nvim-lualine/lualine.nvim'
Plug 'tamton-aquib/staline.nvim'
" If you want to have icons in your statusline choose one of these
Plug 'kyazdani42/nvim-web-devicons'
Plug 'scrooloose/nerdcommenter'
Plug 'tpope/vim-fugitive'
Plug 'mileszs/ack.vim'
Plug 'elixir-editors/vim-elixir'
Plug 'elmcast/elm-vim'
Plug 'rust-lang/rust.vim'
Plug 'ishan9299/nvim-solarized-lua'
Plug 'lifepillar/vim-solarized8'
"Plug 'ishan9299/nvim-solarized-lua'
" Language server stuff
Plug 'neovim/nvim-lspconfig'
Plug 'SmiteshP/nvim-navic'
Plug 'simrat39/rust-tools.nvim'
Plug 'glepnir/lspsaga.nvim', { 'branch': 'main' }
Plug 'folke/lsp-colors.nvim'
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}  " We recommend updating the parsers on update
Plug 'j-hui/fidget.nvim'
Plug 'folke/lsp-colors.nvim'
" Completion
Plug 'hrsh7th/nvim-cmp'
Plug 'hrsh7th/cmp-nvim-lsp'
Plug 'hrsh7th/cmp-vsnip'
Plug 'hrsh7th/vim-vsnip'
Plug 'hrsh7th/cmp-buffer'
Plug 'ray-x/cmp-treesitter'
" All of your Plugins must be added before the following line
call plug#end()
filetype plugin indent on    " required

autocmd vimenter * ++nested colorscheme solarized

set background=light

let g:NERDTreeDirArrowExpandable = '‚ñ∏'
let g:NERDTreeDirArrowCollapsible = '‚ñæ'
set mouse=a
"set ttymouse=xterm2
set autoindent

" Display line numbers on the left
set number

" Reload the file on changes
set autoread

" Use case insensitive search, except when using capital letters
set ignorecase

set colorcolumn=100
set tabstop=2
set shiftwidth=2
" Enable light line
set laststatus=2

"let g:airline#extensions#tabline#enabled = 1
"let g:airline_powerline_fonts = 1
"let g:airline_theme='solarized'

map <C-\> :NERDTreeToggle<CR>
augroup myfiletypes
  " Clear old autocmds in group
  autocmd!
  " autoindent with two spaces, always expand tabs
  autocmd FileType ruby,eruby,yaml,javascript,scss,sass,javascriptreact,coffee setlocal ai sw=2 sts=2 et
  autocmd FileType ruby,eruby,yaml setlocal path+=lib
  autocmd FileType ruby,eruby,yaml setlocal colorcolumn=100
  " Make ?s part of words
  autocmd FileType ruby,eruby,yaml setlocal iskeyword+=?

  " Clojure
  autocmd FileType clojure setlocal colorcolumn=80
  autocmd FileType clojure map <Leader>t :!lein test<cr>

  autocmd FileType proto setlocal ai sw=4 sts=4 et
augroup END

map <C-t> <esc>:tabnew<CR>
set showcmd
set iskeyword+=-

" Mapping <tab> to change navigate on tabs
nmap <tab> :tabnext<CR>
" Mapping shift +  <tab> to go to the previous tab
nmap <S-tab> :tabprevious<CR>

map <C-x> :!pbcopy<CR>
vmap <C-c> :w !pbcopy<CR><CR>
set linespace=4

" Ctrl-P Plugin
let g:ctrlp_map = '<c-p>'
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_cmd = 'CtrlP'


" The Silver Searcher
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0

	let g:ackprg = 'ag --nogroup --nocolor --column'

	cnoreabbrev ag Ack
	cnoreabbrev aG Ack
	cnoreabbrev Ag Ack
	cnoreabbrev AG Ack
endif

" Map Ctrl-A -> Start of line, Ctrl-E -> End of line
map <C-a> <Home>
map <C-e> <End>

set backspace=indent,eol,start " allow backspacing over everything in insert mode

set splitbelow
set splitright

" Splits navigation
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

let mapleader = ","

" Hop to some visible part
nnoremap <silent><leader>w <cmd>lua require'hop'.hint_words()<CR>
nnoremap <silent><leader>L <cmd>lua require'hop'.hint_lines()<CR>

nnoremap <silent><leader>T <cmd>Cargo c<CR>

" s{char}{char} to move to {char}{char}
"nmap s <Plug>(easymotion-overwin-f2)

" Move to line
"map <Leader>L <Plug>(easymotion-bd-jk)
"nmap <Leader>L <Plug>(easymotion-overwin-line)

" Move to word
"map  <Leader>w <Plug>(easymotion-bd-w)
"nmap <Leader>w <Plug>(easymotion-overwin-w)

highlight ExtraWhitespace ctermbg=red guibg=red
highlight DiagnosticHint cterm=underline ctermfg=11 ctermbg=7 gui=underline guibg=LightGrey
highligh SignColumn ctermfg=4 ctermbg=7 gui=bold guibg=Red
highligh GitGutterAdd ctermfg=2 ctermbg=7 guibg=Grey
highligh GitGutterChange ctermfg=2 ctermbg=7 guibg=Grey
match ExtraWhitespace /\s\+$/

autocmd BufWritePre * :%s/\s\+$//e

set incsearch
set clipboard=unnamedplus

"let g:ale_sign_error = '‚úñ'
"let g:ale_sign_warning = '>'
"let g:ale_linters = {
"\   'javascriptreact': ['eslint'],
"\   'javascript': ['eslint'],
"\   'ruby': ['rubocop'],
"\}

"let g:ale_fixers = {
"\   'javascript': ['prettier'],
"\   'svelte': ['prettier'],
"\   'typescript': ['prettier'],
"\   'javascriptreact': ['prettier'],
"\   'css': ['prettier'],
"\   'scss': ['prettier']
"\}

"let g:ale_fix_on_save = 0
"let g:ale_linters_explicit = 0
"let g:ale_set_highlights = 0

"" elm-vim
"let g:elm_format_autosave = 1
"let g:elm_format_fail_silently = 0

" Hide annoying highlights by default
set invhls
map <Leader>h :set invhls <CR>

set foldmethod=syntax
set foldlevel=20

set shortmess+=c


lua << EOF
vim.opt.termguicolors = true
vim.g.solarized_statusline = 'flat'
local navic = require("nvim-navic")
require('lualine').setup {
	options = {
		theme  = 'solarized',
		component_separators = '|',
		section_separators = { left = 'ÓÇ¥', right = 'ÓÇ∂' },
	},
		sections = {
				lualine_c = {
						{ navic.get_location, cond = navic.is_available },
				}
		}
}

require'hop'.setup()
local function goto_definition(split_cmd)
  local util = vim.lsp.util
  local log = require("vim.lsp.log")
  local api = vim.api

  -- note, this handler style is for neovim 0.5.1/0.6, if on 0.5, call with function(_, method, result)
  local handler = function(_, result, ctx)
    if result == nil or vim.tbl_isempty(result) then
      local _ = log.info() and log.info(method, "No location found")
      return nil
    end

    if split_cmd then
      vim.cmd(split_cmd)
    end

    if vim.tbl_islist(result) then
      util.jump_to_location(result[1])

      if #result > 1 then
        util.set_qflist(util.locations_to_items(result))
        api.nvim_command("copen")
        api.nvim_command("wincmd p")
      end
    else
      util.jump_to_location(result)
    end
  end

  return handler
end



vim.lsp.handlers["textDocument/definition"] = goto_definition('tabnew')

-- Setup nvim-cmp.
local cmp = require'cmp'
local has_words_before = function()
  local line, col = unpack(vim.api.nvim_win_get_cursor(0))
  return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match("%s") == nil
end

local feedkey = function(key, mode)
  vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(key, true, true, true), mode, true)
end
cmp.setup({
	snippet = {
		expand = function(args)
		vim.fn["vsnip#anonymous"](args.body)
	end,
	},
			mapping = {
				['<C-d>'] = cmp.mapping.scroll_docs(-4),
				['<C-f>'] = cmp.mapping.scroll_docs(4),
				['<C-Space>'] = cmp.mapping.complete(),
				['<C-e>'] = cmp.mapping.close(),
				['<CR>'] = cmp.mapping.confirm({ select = true }),
				["<Tab>"] = cmp.mapping(function(fallback)
					if cmp.visible() then
						cmp.select_next_item()
					elseif vim.fn["vsnip#available"](1) == 1 then
						feedkey("<Plug>(vsnip-expand-or-jump)", "")
					elseif has_words_before() then
						cmp.complete()
					else
						fallback() -- The fallback function sends a already mapped key. In this case, it's probably `<Tab>`.
					end
				end, { "i", "s" }),

				["<Down>"] = cmp.mapping(function(fallback)
					if cmp.visible() then
						cmp.select_next_item()
					elseif vim.fn["vsnip#available"](1) == 1 then
						feedkey("<Plug>(vsnip-expand-or-jump)", "")
					elseif has_words_before() then
						cmp.complete()
					else
						fallback() -- The fallback function sends a already mapped key. In this case, it's probably `<Tab>`.
					end
				end, { "i", "s" }),

				["<S-Tab>"] = cmp.mapping(function()
					if cmp.visible() then
						cmp.select_prev_item()
					elseif vim.fn["vsnip#jumpable"](-1) == 1 then
						feedkey("<Plug>(vsnip-jump-prev)", "")
					end
				end, { "i", "s" }),

				["<Up>"] = cmp.mapping(function()
					if cmp.visible() then
						cmp.select_prev_item()
					elseif vim.fn["vsnip#jumpable"](-1) == 1 then
						feedkey("<Plug>(vsnip-jump-prev)", "")
					end
				end, { "i", "s" }),
				},
	sources = {
		{ name = 'nvim_lsp' },
		{ name = 'path' },
		{ name = 'treesiter' },
		{ name = 'vsnip' },
		{ name = 'buffer' },
		},
	window = {
		documentation = {
			border={"ü≠Ω", "‚ñî", "ü≠æ", "‚ñï", "ü≠ø", "‚ñÅ", "ü≠º", "‚ñè"},
			-- winhighlight='NormalFloat:Normal,FloatBorder:Normal'
			}
		},
})

local custom_attach = function(client, bufnr)
  -- Helper functions
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  -- Mappings.
  local opts = { noremap=true, silent=true }

    if client.server_capabilities.documentSymbolProvider then
        navic.attach(client, bufnr)
    end

  -- See `:help vim.lsp.*` for documentation on any of the below functions
  buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
end

-- stop p from overwtitting the register (by re-yanking it)
vim.keymap.set( "x", "p", "pgvy")

local capabilities = require('cmp_nvim_lsp').default_capabilities(vim.lsp.protocol.make_client_capabilities())

local rust_opts = {
	tools = { -- rust-tools options
	-- These apply to the default RustSetInlayHints command
	autoSetHints = true,
	inlay_hints = {
		-- Only show inlay hints for the current line
		only_current_line = true,
		},
	},
	server = {
		-- on_attach is a callback called when the language server attachs to the bmesuffer
		on_attach = custom_attach,
		capabilities = capabilities,

		settings = {
			["rust-analyzer"] = {
				checkOnSave = {
					enable = true,
				},
			},
		},
	},
}

require'lspconfig'.tsserver.setup {
  on_attach = custom_attach,
  filetypes = { "typescript", "typescriptreact", "typescript.tsx" },
  cmd = { "typescript-language-server", "--stdio" }
}

require'lspconfig'.svelte.setup{
  on_attach = custom_attach,
  filetypes = { "svelte", "Svelte" },
}

require'nvim-treesitter.configs'.setup {
  ensure_installed = { "rust", "svelte", "typescript", "proto" }, -- one of "all", "maintained" (parsers with maintainers), or a list of languages
  highlight = {
    enable = true,              -- false will disable the whole extension
  },
  indent = {
    enable = true
  }
}

vim.diagnostic.config({
  virtual_text = false,
})


require'rust-tools'.setup(rust_opts)
require'lspsaga'.init_lsp_saga()

local keymap = vim.keymap.set
-- Lsp finder find the symbol definition implement reference
-- when you use action in finder like open vsplit then you can
-- use <C-t> to jump back
keymap("n", "gh", "<cmd>Lspsaga lsp_finder<CR>", { silent = true })

-- Code action
keymap("n", "<leader><space>", "<cmd>Lspsaga code_action<CR>", { silent = true })
keymap("v", "<leader><space>", "<cmd>Lspsaga range_code_action<CR>", { silent = true })

-- Rename
keymap("n", "gr", "<cmd>Lspsaga rename<CR>", { silent = true })

-- Definition preview
keymap("n", "gd", "<cmd>Lspsaga preview_definition<CR>", { silent = true })

-- Show line diagnostics
keymap("n", "<leader>cd", "<cmd>Lspsaga show_line_diagnostics<CR>", { silent = true })

-- Show cursor diagnostic
keymap("n", "<leader>cd", "<cmd>Lspsaga show_cursor_diagnostics<CR>", { silent = true })

-- Diagnsotic jump can use `<c-o>` to jump back
keymap("n", "[e", "<cmd>Lspsaga diagnostic_jump_prev<CR>", { silent = true })
keymap("n", "]e", "<cmd>Lspsaga diagnostic_jump_next<CR>", { silent = true })

-- Only jump to error
keymap("n", "[E", function()
  require("lspsaga.diagnostic").goto_prev({ severity = vim.diagnostic.severity.ERROR })
end, { silent = true })
keymap("n", "]E", function()
  require("lspsaga.diagnostic").goto_next({ severity = vim.diagnostic.severity.ERROR })
end, { silent = true })

-- Outline
keymap("n","<leader>o", "<cmd>LSoutlineToggle<CR>",{ silent = true })

-- Hover Doc
keymap("n", "K", "<cmd>Lspsaga hover_doc<CR>", { silent = true })

-- Float terminal
keymap("n", "<A-d>", "<cmd>Lspsaga open_floaterm<CR>", { silent = true })
-- close floaterm
keymap("t", "<A-d>", [[<C-\><C-n><cmd>Lspsaga close_floaterm<CR>]], { silent = true })

require"fidget".setup{
 text = {
	 spinner = "dots"
	}
}
EOF

" Use <Tab> and <S-Tab> to navigate through popup menu
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

"imap <tab> <Plug>(completion_smart_tab)
"imap <s-tab> <Plug>(completion_smart_s_tab)

" Set completeopt to have a better completion experience
set completeopt=menuone,noinsert,noselect

" Avoid showing message extra message when using completion
set shortmess+=c

let g:rustfmt_autosave = 1

